RSB INTEGRATION PATTERNS FOR RUST PROJECTS
==========================================

Date: 2025-09-08
Target: RSB Integration Strategies & Adapter Patterns
Source: docs/RSB_ADAPTER_PATTERN.md, docs/RSB_COMPREHENSIVE_GUIDE.md

INTEGRATION STRATEGY OVERVIEW
==============================

RSB provides multiple integration strategies to balance string-first simplicity 
with complex system requirements. The key is knowing when to use each approach.

CORE INTEGRATION PRINCIPLES
============================

1. STRING-FIRST BOUNDARY MAINTENANCE
   ‚Ä¢ RSB interfaces always remain string-based
   ‚Ä¢ Complex systems isolated behind adapters
   ‚Ä¢ Translation layers convert between paradigms
   ‚Ä¢ No RSB pollution in adapter modules

2. LAYERED INTEGRATION ARCHITECTURE
   ‚Ä¢ RSB Layer: String-first public APIs
   ‚Ä¢ Adapter Layer: Standard Rust patterns for complex systems
   ‚Ä¢ System Layer: Direct library/database integration

WHEN TO USE DIFFERENT INTEGRATION PATTERNS
===========================================

‚úÖ DIRECT RSB PATTERNS (Preferred)
----------------------------------
Use For:
‚Ä¢ Simple file operations
‚Ä¢ Basic string processing  
‚Ä¢ Command-line argument parsing
‚Ä¢ Configuration management
‚Ä¢ Stream processing
‚Ä¢ Unix-style operations

Implementation:
‚Ä¢ Use RSB macros directly
‚Ä¢ cat!(), grep(), sed() operations
‚Ä¢ param!() for configuration
‚Ä¢ validate!() for input checking

‚ùå DIRECT RSB NOT SUITABLE
---------------------------
Avoid For:
‚Ä¢ Database integration with complex queries
‚Ä¢ Cryptographic operations requiring type safety
‚Ä¢ Network protocols with structured data
‚Ä¢ Performance-critical operations
‚Ä¢ Third-party libraries with their own patterns

Solution: Use Adapter Pattern (see below)

ADAPTER PATTERN IMPLEMENTATION
===============================

PATTERN STRUCTURE:
1. Isolated Standard Rust Module (adapters/)
2. RSB String-First Interface Wrapper
3. Clean Module Organization
4. Error Translation Layer

1. ISOLATED STANDARD RUST MODULE
-------------------------------
```rust
// src/prontodb/adapters/database.rs
// This module can use full Rust power - types, traits, etc.

use rusqlite::{Connection, Result, Row};
use serde_json::Value;

pub struct DatabaseAdapter {
    conn: Connection,
}

impl DatabaseAdapter {
    pub fn new(db_path: &str) -> Result<Self, Box<dyn std::error::Error>> {
        let conn = Connection::open(db_path)?;
        Ok(Self { conn })
    }
    
    // Standard Rust patterns - complex types OK here
    pub fn insert_key_value(&self, project: &str, namespace: &str, key: &str, value: &Value) -> Result<(), Box<dyn std::error::Error>> {
        // Full SQL power, proper error handling, etc.
    }
    
    pub fn get_value(&self, project: &str, namespace: &str, key: &str) -> Result<Option<String>, Box<dyn std::error::Error>> {
        // Complex query logic with proper typing
    }
}
```

2. RSB STRING-FIRST INTERFACE WRAPPER
-------------------------------------
```rust
// src/prontodb/core.rs - Business logic tier
use super::adapters::database::DatabaseAdapter;

// String-first wrapper around the adapter
pub fn _helper_set(key: &str, value: &str) -> Result<(), String> {
    let addr = _parse_address(key)?;
    
    // Initialize adapter (could be cached/singleton)
    let db = _get_database_adapter()?;
    
    // Convert RSB strings to adapter format
    let json_value: serde_json::Value = serde_json::from_str(value)
        .unwrap_or_else(|_| serde_json::Value::String(value.to_string()));
    
    // Call adapter with string parameters
    db.insert_key_value(&addr.project, &addr.namespace, &addr.key, &json_value)
        .map_err(|e| e.to_string())?;
        
    Ok(())
}

// RSB pattern: string-first configuration
fn _get_database_adapter() -> Result<DatabaseAdapter, String> {
    let home = std::env::var("HOME").map_err(|_| "HOME not set")?;
    let db_path = format!("{}/.local/data/odx/prontodb/store.db", home);
    
    DatabaseAdapter::new(&db_path).map_err(|e| e.to_string())
}
```

3. PROJECT STRUCTURE WITH ADAPTERS
----------------------------------
```
src/prontodb/
‚îú‚îÄ‚îÄ mod.rs              # Re-exports
‚îú‚îÄ‚îÄ handlers.rs         # RSB public API (do_* functions)
‚îú‚îÄ‚îÄ core.rs            # RSB business logic (_helper_* functions)  
‚îú‚îÄ‚îÄ utils.rs           # RSB system operations (__blind_faith_* functions)
‚îî‚îÄ‚îÄ adapters/          # Standard Rust modules
    ‚îú‚îÄ‚îÄ mod.rs         # Adapter interface
    ‚îú‚îÄ‚îÄ database.rs    # SQLite adapter
    ‚îú‚îÄ‚îÄ crypto.rs      # Encryption adapter (optional)
    ‚îî‚îÄ‚îÄ network.rs     # HTTP adapter (optional)
```

4. CLEAN MODULE INTERFACE
------------------------
```rust
// src/prontodb/adapters/mod.rs
pub mod database;

// Optional: Common adapter traits
pub trait StorageAdapter {
    fn set(&self, key: &str, value: &str) -> Result<(), String>;
    fn get(&self, key: &str) -> Result<Option<String>, String>;
}
```

SQL INTEGRATION PATTERN
========================

COMPILE-TIME SQL LOADING:
```rust
// Load SQL queries as compile-time constants
const FIND_USERS_SQL: &str = include_str!("../queries/find_users.sql");
const CREATE_USER_SQL: &str = include_str!("../queries/create_user.sql");

// RSB string-first database interface
pub fn db_query(db_path: &str, query_name: &str, params: &[&str]) -> String {
    let query = match query_name {
        "find_users" => FIND_USERS_SQL,
        "create_user" => CREATE_USER_SQL,
        _ => fatal!("Unknown query: {}", query_name),
    };
    
    let final_query = _substitute_params(query, params);
    _execute_query(db_path, &final_query)
}
```

DIRECTORY STRUCTURE:
```
src/prontodb/queries/
‚îú‚îÄ‚îÄ users.sql           # User-related queries
‚îú‚îÄ‚îÄ projects.sql        # Project namespace queries  
‚îú‚îÄ‚îÄ keys.sql           # Key-value operations
‚îî‚îÄ‚îÄ maintenance.sql    # Database maintenance
```

ERROR TRANSLATION STRATEGY
===========================

ADAPTER ERROR ‚Üí RSB STRING CONVERSION:
```rust
// Complex adapter errors converted to simple RSB strings
adapter_result.map_err(|complex_error| {
    // Log detailed error internally for debugging
    log::error!("Database error: {:?}", complex_error);
    
    // Return simple string for RSB layer
    match complex_error {
        DatabaseError::NotFound => "Key not found".to_string(),
        DatabaseError::InvalidFormat => "Invalid data format".to_string(),
        DatabaseError::ConnectionFailed => "Database unavailable".to_string(),
        _ => "Database operation failed".to_string(),
    }
})
```

CONFIGURATION INTEGRATION
==========================

RSB CONFIGURATION LOADING:
```rust
// RSB pattern: string-based configuration
fn _load_database_config() -> Result<String, String> {
    // Use RSB configuration macros
    let db_path = param!("PRONTO_DB_PATH", 
                        default: format!("{}/.local/data/odx/prontodb/store.db", 
                                       param!("HOME")));
    
    validate!(test!(-d dirname(&db_path)), "Database directory not accessible");
    Ok(db_path)
}
```

ADAPTER PATTERN BENEFITS
=========================

üèóÔ∏è ARCHITECTURAL INTEGRITY:
‚Ä¢ RSB string-first interface preserved
‚Ä¢ Complex Rust power isolated in adapters
‚Ä¢ Clean separation of concerns
‚Ä¢ Easy to test both layers independently

üîÑ FLEXIBILITY:
‚Ä¢ Can swap adapters (SQLite ‚Üí PostgreSQL)
‚Ä¢ Standard Rust ecosystem compatibility  
‚Ä¢ Performance optimization possible in adapters
‚Ä¢ Type safety where it matters

üì¶ RSB COMPLIANCE:
‚Ä¢ Three-tier function ordinality maintained
‚Ä¢ String-first public interfaces
‚Ä¢ Error handling converted to RSB patterns
‚Ä¢ Configuration stays simple

PRONTODB IMPLEMENTATION ROADMAP
===============================

PHASE 1: BASIC SQLITE ADAPTER
-----------------------------
```rust
DatabaseAdapter::set_kv(project, namespace, key, value) -> Result<(), Error>
DatabaseAdapter::get_kv(project, namespace, key) -> Result<Option<String>, Error>
DatabaseAdapter::del_kv(project, namespace, key) -> Result<usize, Error>
```

PHASE 2: ADVANCED FEATURES
--------------------------
```rust
DatabaseAdapter::set_with_ttl(...)
DatabaseAdapter::query_json(...)  
DatabaseAdapter::transaction(...)
```

PHASE 3: MULTI-BACKEND SUPPORT
------------------------------
```rust
trait StorageBackend { ... }
impl StorageBackend for SqliteBackend { ... }
impl StorageBackend for PostgresBackend { ... }
```

CRITICAL REQUIREMENTS
======================

‚ö†Ô∏è RSB INTERFACE CONTRACT:
‚Ä¢ Input: Always strings from RSB layer
‚Ä¢ Output: Always strings or simple errors back to RSB
‚Ä¢ Configuration: String-based paths, simple parameters
‚Ä¢ No RSB Pollution: Adapters should not know about RSB patterns

üîê ERROR TRANSLATION MANDATORY:
‚Ä¢ Complex errors must be translated to simple strings
‚Ä¢ Internal detailed logging for debugging
‚Ä¢ User-friendly error messages for RSB layer

üêî Summary Status: COMPLETE INTEGRATION GUIDE
This egg provides the complete integration strategy needed to balance RSB simplicity with complex system requirements.

DISCLAIMER
----------
‚ö†Ô∏è This integration guide reflects documented RSB patterns.
Adapter implementations must maintain strict separation between RSB and standard Rust layers.
Test both layers independently to ensure proper isolation.